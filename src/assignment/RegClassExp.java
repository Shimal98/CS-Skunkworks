package assignment;

/*
 *  Class representing a character class tree in a RegExp expression tree.
 */
public class RegClassExp extends RegExp {
	
	protected char lower,  // lower limit of class
	               upper;  // upper limit of class
	
	/*
	 * Construct a new character node with specified lower
	 * and upper limits for the class
	 */
	public RegClassExp(char lower,
	                   char upper) {
		
		this.lower = lower;
		this.upper = upper;				
	}
	
	/*
	 * Make and return a Nfa for this character class expression tree
	 */
	public Nfa makeNfa() {
		NfaState acceptState = new NfaState(null, null, NfaState.EPSILON, 2);
		NfaState startState = new NfaState(acceptState, null, lower, 1);
		Nfa classNfa = new Nfa(startState, acceptState, 2);
		for(char letter = lower; letter <= upper; letter++) {
			// Prototypical NFA accepting a string in the language generated by [a-z] for example
			NfaState newAcceptState = new NfaState(null, null, NfaState.EPSILON, classNfa.getNumStates() + 1);
			// Thompson's contruction in motion here
			NfaState newSymbolState = new NfaState(newAcceptState, null, NfaState.EPSILON, classNfa.getNumStates() + 2);
			NfaState alternationState = new NfaState(newSymbolState, null, letter, classNfa.getNumStates() + 3);
			NfaState newStartState = new NfaState(classNfa.getStart(), alternationState, NfaState.EPSILON, NfaState.EPSILON, classNfa.getNumStates() + 3);
			
			//Modifying old accept state in classNfa to link up to new accept state
			classNfa.getAccept().setNext1(newAcceptState);;
			
			
			classNfa.setStart(newStartState);
			classNfa.setAccept(newAcceptState);
		}
         return classNfa;          // Dummy return to keep Java happy
	}
	
	/*
	 *  Decompile this character class expression tree back to its original
	 *  form as a string
	 */
	public String decompile() {
		
		return "[" + lower + "-" + upper + "]";
	}
}